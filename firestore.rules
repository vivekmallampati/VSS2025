rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is a superadmin
    function isSuperadmin() {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superadmin';
    }
    
    // Helper function to check if user owns the registration
    function isOwnerOfRegistration(registrationId) {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniqueId == registrationId;
    }
    
    // Helper function to check if uniqueId is associated with user's email via emailToUids
    function isUniqueIdAssociatedWithEmail(uniqueId) {
      let userEmail = exists(/databases/$(database)/documents/users/$(request.auth.uid)) 
        ? (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email != null 
           ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email.lower() 
           : (request.auth.token.email != null ? request.auth.token.email.lower() : ''))
        : (request.auth.token.email != null ? request.auth.token.email.lower() : '');
      
      return userEmail != '' &&
             exists(/databases/$(database)/documents/emailToUids/$(userEmail)) &&
             get(/databases/$(database)/documents/emailToUids/$(userEmail)).data.uids != null &&
             checkUniqueIdInArray(get(/databases/$(database)/documents/emailToUids/$(userEmail)).data.uids, uniqueId);
    }
    
    // Helper function to check if uniqueId is in the uids array (checks first 10 elements)
    function checkUniqueIdInArray(uids, uniqueId) {
      let normalizedTargetId = normalizeId(uniqueId);
      return (uids.size() > 0 && uids[0] != null && (uids[0] == uniqueId || normalizeId(uids[0]) == normalizedTargetId)) ||
             (uids.size() > 1 && uids[1] != null && (uids[1] == uniqueId || normalizeId(uids[1]) == normalizedTargetId)) ||
             (uids.size() > 2 && uids[2] != null && (uids[2] == uniqueId || normalizeId(uids[2]) == normalizedTargetId)) ||
             (uids.size() > 3 && uids[3] != null && (uids[3] == uniqueId || normalizeId(uids[3]) == normalizedTargetId)) ||
             (uids.size() > 4 && uids[4] != null && (uids[4] == uniqueId || normalizeId(uids[4]) == normalizedTargetId)) ||
             (uids.size() > 5 && uids[5] != null && (uids[5] == uniqueId || normalizeId(uids[5]) == normalizedTargetId)) ||
             (uids.size() > 6 && uids[6] != null && (uids[6] == uniqueId || normalizeId(uids[6]) == normalizedTargetId)) ||
             (uids.size() > 7 && uids[7] != null && (uids[7] == uniqueId || normalizeId(uids[7]) == normalizedTargetId)) ||
             (uids.size() > 8 && uids[8] != null && (uids[8] == uniqueId || normalizeId(uids[8]) == normalizedTargetId)) ||
             (uids.size() > 9 && uids[9] != null && (uids[9] == uniqueId || normalizeId(uids[9]) == normalizedTargetId));
    }
    
    // Helper function to check if uniqueId is in user's associated registrations
    function isUniqueIdInAssociatedRegistrations(uniqueId) {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.associatedRegistrations != null;
    }
    
    // Helper function to normalize Praveshika ID for comparison
    function normalizeId(id) {
      return id.lower().replaceAll('/', '').replaceAll('-', '');
    }
    
    // Helper function to check if user is an admin (superadmin or admin)
    function isAdmin() {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superadmin' ||
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
    }
    
    // Helper function to check if user is a volunteer
    function isVolunteer() {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'volunteer';
    }
    
    // Helper function to get volunteer teams (array of strings like
    // ["transportation", "registration", "ganvesh_collected", "cloak_room", "post_tour"])
    function getVolunteerTeams() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.volunteerTeams;
    }
    
    // Helper function to check if volunteer has access to checkin type
    function volunteerHasAccess(checkinType) {
      let teams = getVolunteerTeams();
      // Map checkin types to team names
      // Note: shulk_paid and kit_collected are part of registration, so they map to 'registration' team
      let teamMap = {
        'pickup_location': 'transportation',
        'registration': 'registration',
        'shulk_paid': 'registration',
        'kit_collected': 'registration',
        'ganvesh_collected': 'ganvesh_collected',
        'cloak_room': 'cloak_room',
        'post_tour': 'post_tour'
      };
      let requiredTeam = teamMap[checkinType];
      // Check if requiredTeam exists in teams array
      // Note: Firestore rules don't support array.includes(), so we check if any element matches
      return requiredTeam != null && teams != null && requiredTeam in teams;
    }
    
    // Registrations collection (only Approved shibirarthis)
    match /registrations/{uniqueId} {
      // Anyone can read for verification
      allow read: if true;
      
      // Allow creating registration records if:
      // 1. User is an admin (can create for others)
      // 2. User is creating their own registration record (for volunteer/admin user creation flow)
      allow create: if request.auth != null && 
                       (isAdmin() || 
                        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniqueId == uniqueId));
      // Only admin SDK can delete (moved to cancelledRegistrations)
      allow delete: if false;
      
      // Allow authenticated users to update only their own transportation info
      // OR allow admins to update any field
      allow update: if request.auth != null && 
                       (
                         // Admin can update any field (uniqueId must match document ID)
                         // This handles both cases: when document has uniqueId and when it doesn't (data integrity fix)
                         (isAdmin() && request.resource.data.uniqueId == uniqueId) ||
                         // Regular users can update only their own transportation info
                         (
                           // Check if user's uniqueId matches (normalized comparison)
                           (isOwnerOfRegistration(uniqueId) ||
                            // Also check normalized comparison for flexible matching
                            (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                             normalizeId(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniqueId) == normalizeId(uniqueId)) ||
                            // Check if uniqueId is associated with user's email via emailToUids
                            isUniqueIdAssociatedWithEmail(uniqueId) ||
                            // Check if uniqueId is in user's associated registrations
                            isUniqueIdInAssociatedRegistrations(uniqueId)) &&
                           // Allow updating transportation-related fields and tour selection (normalized field names)
                           request.resource.data.diff(resource.data).affectedKeys()
                             .hasOnly(['arrivalDate', 'arrivalTime', 'arrivalPlace', 'arrivalFlightTrain', 'pickupNeeded',
                                      'departureDate', 'departureTime', 'departurePlace', 'departureFlightTrain', 'dropoffNeeded',
                                      'postShibirTour', 'travelupdateAt', 'tourupdateAt', 'updatedAt']) &&
                           // Ensure critical fields are not modified
                           // Handle case where document might not have uniqueId (compare with document ID parameter)
                           (request.resource.data.uniqueId == uniqueId || 
                            (resource.data.uniqueId != null && request.resource.data.uniqueId == resource.data.uniqueId)) &&
                           // Preserve normalizedId if it exists
                           (resource.data.normalizedId == null || request.resource.data.normalizedId == resource.data.normalizedId) &&
                           // Preserve name and email for regular users
                           request.resource.data.name == resource.data.name &&
                           request.resource.data.email == resource.data.email
                         )
                       );
    }
    
    // Users collection
    match /users/{userId} {
      // Allow reading user data in specific cases:
      // 1. Users can read their own data
      // 2. Admins can read all user data
      // 3. Allow querying by uniqueId for login purposes (unauthenticated users can query)
      //    but limit to only returning email/uniqueId fields for security
      allow read: if request.auth != null && (request.auth.uid == userId || isAdmin());
      // Allow list/query operations for login lookup by uniqueId (before authentication)
      allow list: if request.query.limit <= 1;
      // Users can create/update their own data
      allow create, update: if request.auth != null && request.auth.uid == userId;
      // Admins can also create user documents (for new user creation)
      allow create: if request.auth != null && isAdmin();
      // Only admins can delete user documents
      allow delete: if request.auth != null && isAdmin();
    }
    
    // EmailToUids collection - maps emails to associated uniqueIds
    // Document ID is normalized email (lowercase)
    match /emailToUids/{normalizedEmail} {
      // Authenticated users can read their own email mapping, admins can read all
      // The document ID is the normalized email (lowercase), compare with normalized user email
      allow read: if request.auth != null && 
                    (isAdmin() ||
                     normalizedEmail == request.auth.token.email.lower() ||
                     (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                      get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email.lower() == normalizedEmail));
      // Only admin can create/update/delete (handled via Admin SDK)
      allow create, update, delete: if false;
    }
    
    // ContactMessages collection - public contact form submissions
    match /contactMessages/{messageId} {
      // Anyone can create contact messages (contact form is public)
      allow create: if true;
      // Admins (superadmin or admin) can read contact messages
      allow read: if isAdmin();
      // No updates or deletes allowed (contact messages are immutable)
      allow update, delete: if false;
    }
    
    // Checkins collection
    match /checkins/{checkinId} {
      // Helper function to check if user owns this checkin
      function isOwnerOfCheckin() {
        return request.auth != null && 
               exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
               normalizeId(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniqueId) == normalizeId(resource.data.uniqueId);
      }
      
      // Helper function to check if user created this checkin
      function isCreatorOfCheckin() {
        return request.auth != null && resource.data.checkedInBy == request.auth.uid;
      }
      
      // Superadmins and admins can read all checkins
      allow read: if request.auth != null && isAdmin();
      // Volunteers can read checkins for their assigned teams OR checkins they created
      allow read: if request.auth != null && isVolunteer() && 
                    (volunteerHasAccess(resource.data.checkinType) || isCreatorOfCheckin());
      // Participants can read their own checkins (by uniqueId match)
      allow read: if request.auth != null && 
                    exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                    isOwnerOfCheckin();
      
      // Superadmins and admins can create checkins for anyone
      allow create: if request.auth != null && isAdmin();
      // Volunteers can create checkins for their assigned teams
      allow create: if request.auth != null && isVolunteer() && volunteerHasAccess(request.resource.data.checkinType);
      
      // Superadmins and admins can update all checkins
      allow update: if request.auth != null && isAdmin();
      // Volunteers can update checkins for their assigned teams
      allow update: if request.auth != null && isVolunteer() && volunteerHasAccess(resource.data.checkinType);
      
      // Superadmins and admins can delete all checkins
      allow delete: if request.auth != null && isAdmin();
      // Volunteers can delete checkins for their assigned teams
      allow delete: if request.auth != null && isVolunteer() && volunteerHasAccess(resource.data.checkinType);
      
      // Allow list queries for authenticated users
      // Note: Firestore will still enforce document-level read rules, so users will only see their own checkins
      // This allows the query to execute, but results are filtered by the read rules above
      allow list: if request.auth != null && 
                   (isAdmin() || 
                    isVolunteer() || 
                    exists(/databases/$(database)/documents/users/$(request.auth.uid)));
    }
    
    // Non-Shibirarthi Users collection (volunteers and admins)
    match /nonShibirarthiUsers/{uniqueId} {
      // Admins can read all
      allow read: if request.auth != null && isAdmin();
      // Users can read their own record
      allow read: if request.auth != null && 
                    (isOwnerOfRegistration(uniqueId) ||
                     (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                      normalizeId(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniqueId) == normalizeId(uniqueId)));
      // Allow unauthenticated queries limited to 1 result for login purposes
      // This allows checking if email exists during login flow before authentication
      allow list: if request.query != null && request.query.limit <= 1;
      // Only admins can create/update/delete
      allow create, update, delete: if request.auth != null && isAdmin();
    }
    
    // Cancelled Registrations collection
    match /cancelledRegistrations/{uniqueId} {
      // Only admins can read cancelled registrations
      allow read: if request.auth != null && isAdmin();
      // Only admins can create/update/delete (for moving between collections)
      allow create, update, delete: if request.auth != null && isAdmin();
    }
  }
}

