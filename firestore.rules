rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is a superadmin
    function isSuperadmin() {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superadmin';
    }
    
    // Helper function to check if user owns the registration
    function isOwnerOfRegistration(registrationId) {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniqueId == registrationId;
    }
    
    // Helper function to normalize Praveshika ID for comparison
    function normalizeId(id) {
      return id.lower().replaceAll('/', '').replaceAll('-', '');
    }
    
    // Helper function to check if user is an admin (superadmin or admin)
    function isAdmin() {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superadmin' ||
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
    }
    
    // Helper function to check if user is a volunteer
    function isVolunteer() {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'volunteer';
    }
    
    // Helper function to get volunteer teams
    function getVolunteerTeams() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.volunteerTeams;
    }
    
    // Helper function to check if volunteer has access to checkin type
    function volunteerHasAccess(checkinType) {
      let teams = getVolunteerTeams();
      // Map checkin types to team names
      let teamMap = {
        'pickup_location': 'transportation',
        'venue_entrance': 'venue_entrance',
        'cloak_room': 'cloak_room',
        'accommodation': 'accommodation',
        'food': 'food',
        'post_tour': 'post_tour'
      };
      let requiredTeam = teamMap[checkinType];
      // Check if requiredTeam exists in teams array
      // Note: Firestore rules don't support array.includes(), so we check if any element matches
      return requiredTeam != null && teams != null && requiredTeam in teams;
    }
    
    // Registrations collection
    match /registrations/{uniqueId} {
      // Anyone can read for verification
      allow read: if true;
      
      // Only admin can create/delete (handled via Admin SDK)
      allow create, delete: if false;
      
      // Allow authenticated users to update only their own transportation info
      allow update: if request.auth != null && 
                       // Check if user's uniqueId matches (normalized comparison)
                       (isOwnerOfRegistration(uniqueId) ||
                        // Also check normalized comparison for flexible matching
                        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                         normalizeId(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniqueId) == normalizeId(uniqueId))) &&
                       // Only allow updating transportation-related fields (tours are read-only)
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['pickupLocation', 'Pickup Location', 'arrivalDate', 'Arrival Date',
                                  'arrivalTime', 'Arrival Time', 'flightTrainNumber', 'Flight/Train Number',
                                  'returnDate', 'Return Date', 'returnTime', 'Return Time',
                                  'returnFlightTrainNumber', 'Return Flight/Train Number',
                                  'transportationUpdatedAt']) &&
                       // Ensure critical fields are not modified
                       request.resource.data.uniqueId == resource.data.uniqueId &&
                       request.resource.data.normalizedId == resource.data.normalizedId &&
                       request.resource.data.name == resource.data.name &&
                       request.resource.data.email == resource.data.email;
    }
    
    // Users collection
    match /users/{userId} {
      // Users can read their own data, superadmins can read all user data
      allow read: if request.auth != null && (request.auth.uid == userId || isSuperadmin());
      // Users can create/update their own data
      allow create, update: if request.auth != null && request.auth.uid == userId;
      // Users cannot delete their own data (admin only)
      allow delete: if false;
    }
    
    // EmailToUids collection - maps emails to associated uniqueIds
    // Document ID is normalized email (lowercase)
    match /emailToUids/{normalizedEmail} {
      // Authenticated users can read their own email mapping, superadmins can read all
      // The document ID is the normalized email (lowercase), compare with normalized user email
      allow read: if request.auth != null && 
                    (isSuperadmin() ||
                     normalizedEmail == request.auth.token.email.lower() ||
                     (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                      get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email.lower() == normalizedEmail));
      // Only admin can create/update/delete (handled via Admin SDK)
      allow create, update, delete: if false;
    }
    
    // ContactMessages collection - public contact form submissions
    match /contactMessages/{messageId} {
      // Anyone can create contact messages (contact form is public)
      allow create: if true;
      // Only superadmins can read contact messages
      allow read: if isSuperadmin();
      // No updates or deletes allowed (contact messages are immutable)
      allow update, delete: if false;
    }
    
    // Checkins collection
    match /checkins/{checkinId} {
      // Superadmins and admins can read all checkins
      allow read: if request.auth != null && isAdmin();
      // Volunteers can read checkins for their assigned teams
      allow read: if request.auth != null && isVolunteer() && volunteerHasAccess(resource.data.checkinType);
      // Participants can read their own checkins
      allow read: if request.auth != null && 
                    exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                    normalizeId(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniqueId) == normalizeId(resource.data.uniqueId);
      
      // Superadmins and admins can create checkins for anyone
      allow create: if request.auth != null && isAdmin();
      // Volunteers can create checkins for their assigned teams
      allow create: if request.auth != null && isVolunteer() && volunteerHasAccess(request.resource.data.checkinType);
      
      // Superadmins and admins can update all checkins
      allow update: if request.auth != null && isAdmin();
      // Volunteers can update checkins for their assigned teams
      allow update: if request.auth != null && isVolunteer() && volunteerHasAccess(resource.data.checkinType);
      
      // Only superadmins and admins can delete checkins
      allow delete: if request.auth != null && isAdmin();
    }
  }
}

